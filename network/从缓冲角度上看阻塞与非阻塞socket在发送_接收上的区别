--------------------------------------------------------------
从缓冲角度上,看阻塞与非阻塞socket在发送/接收上的区别:
--------------------------------------------------------------
	很多人在描述两者的 
	发送/接收时操作返回 以及 缓冲区处理的区别时, 有不同程度的误解。

	首先socket在默认情况下是阻塞状态的(未指异步操作以及其它一些特殊用途下,直接默认为阻塞),这就使得发送/接收操作处于阻塞的状态，即调用不会立即返回，
	而是进入睡眠等待操作完成。


下面分为发送与接收讨论:

一.发送选用send（特指TCP）以及sendto（特指UDP）来描述

	首先需要说明的是，不管阻塞还是非阻塞，在发送时都会将数据从应用缓冲区,拷贝到内核缓冲区（SO_RCVBUF选项声明，除非缓冲区大小为0）。
	网络上看到某些人说，阻塞就是将数据真正发送给对方，并且阻塞是发生在需要把前面的所有数据全部发送出去，然后再发送本次的，而非阻塞则是拷贝到发送缓冲区。
	上面的这种说法是错误的。

	--------------------------------------------------------------
	在阻塞模式下
	send操作将会等所有数据均被拷贝到内核空间的发送缓冲区后才会返回。
	--------------------------------------------------------------
	
	如果当前内核发送缓冲总大小为8192，已经拷贝到缓冲趣的数据为8000，那剩余的大小为192，现在需要发送2000字节数据，
	那阻塞发送,就会等待缓冲区足够把所有2000字节数据拷贝进去，如第一次拷贝进192字节，当缓冲区成功发送出1808字节后，再把应用缓冲区剩余的1808字节拷贝到内核缓冲，
	而后send操作返回成功发送字节数。
	
	不难看出，阻塞的send()返回的发送大小，必然是你参数中的发送长度的大小。
	
	UDP:
	而在阻塞模式下的sendto()操作就不会阻塞。
	原因在于：
		UDP并没有真正的发送缓冲区，它所做的只是将应用缓冲区拷贝给下层协议栈，在此过程中加上UDP头，IP头，所以实际不存在阻塞。

	--------------------------------------------------------------
    	在非阻塞模式下
	send操作调用会立即返回。
	--------------------------------------------------------------
	
	关于立即返回大家都不会有异议。还是拿阻塞send的那个例子来看，当缓冲区只有192字节，但是却需要发送2000字节时，此时调用立即返回，并得到返回值为192。
	从中可以看到，非阻塞send仅仅是尽自己的能力向缓冲区拷贝尽可能多的数据，因此在非阻塞下send才有可能返回比你参数中的发送长度小的值。

	如果缓冲区没有任何空间时呢？这时肯定也是立即返回，但是你会得到WSAEWOULDBLOCK/E WOULDBLOCK 的错误，此时表示你无法拷贝任何数据到缓冲区，
	你最好休息一下再尝试发送。

	在非阻塞模式下sendto操作 不会阻塞（与阻塞一致,不说明）。

 

二.接收选用recv（特指TCP）以及recvfrom（特指UDP）来描述

	在阻塞模式下recv，recvfrom操作,将会阻塞到缓冲区里有至少一个字节（TCP）或者一个完整UDP数据报才返回。在没有数据到来时，对它们的调用都将处于睡眠状态，不会返回。

	在非阻塞模式下recv，recvfrom操作将会立即返回。
		如果缓冲区有任何一个字节数据（TCP）或者一个完整UDP数据报，它们将会返回接收到的数据大小。而
		如果没有任何数据则返回错误 WSAEWOULDBLOCK/E WOULDBLOCK。

